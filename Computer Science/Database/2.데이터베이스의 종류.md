## 4.4 데이터베이스의 종류
### 개요

RDMBS 와 NoSQL 에 어떠한 종류의 데이터베이스들이 있는지 알아봅시다.
<!-- TOC -->
### **목차**
- [관계형 데이터베이스](#관계형-데이터베이스)
  - MySQL
  - PostgreSQL
- NoSQL 데이터베이스
  - MongoDB
  - redis
- 인덱스
  - 인덱스 만드는법
  - 인덱스 최적화 기법
- 조인의 종류
  - 내부조인
  - 왼쪽조인
  - 오른쪽조인
  - 합집합조인
- 조인의 원리
  - 중첩루프조인
  - 정렬병합조인
  - 해시조인
    - 빌드단계
    - 프로브단계
   
### 관계형 데이터베이스
- 개념
  - 관계형 데이터베이스(RDBMS)는 행과 열을 가지는 표 형식 데이터를 저장하는 형태의 데이터베이스를 가리키며 SQL 이라는 언어를 써서 조작한다.
- 특징
  - MySQL, PostgreSQL, 오라클, SQL server, MSSQL 등이 있다.
  - 표준 SQL을 지키지만, 각각의 제품을 특화시킨 SQL을 사용한다.
    - 예시) 오라클의 경우 PL/SQL, SQL server 에서는 T-SQL, MySQL은 SQL을 사용한다.
### MySQL
- 특징
  - RDBMS의 한 종류로써 대부분의 운영체제와 호환되며 현재 가장 많이 사용하는 데이터베이스이다. 
  - C, C++로 만들어졌으며 MyISAM 인덱스 압축 기술, B-트리 기반의 인덱스, 스레드 기반의 메모리 할당 시스템, 매우 빠른 조인, 최대 64개의 인덱스를 제공한다.
  - 대용량 데이터베이스를 위해 설계되어 있고, 롤백, 커밋, 이중암호 지원 보안 등의 기능을 제공한다.
    
![image](https://github.com/ukukdin/basic_CS_study/assets/97656198/24c631e6-64b7-41eb-aafe-cd03ae38cd81)

### PostreSQL
- 특징
  - 디스크 조각이 차지하는 영역을 회수할 수 있는 장치인 VACUUM이 특징이다. 최대 테이블의 크기는 32TB이다.
  - SQL 뿐만 아니라 JSON을 이용해서 데이터에 접근할 수 있다.
  - 지정 시간에 복구하는 기능, 로깅, 접근 제어, 중첩된 트랜잭션, 백업 등을 할 수 있다.

### NoSQL 데이터베이스
- 특징
  - NoSQL(Not only SQL) 이라는 슬로건에서 생겨난 데이터베이스이다.
  - SQL 을 사용하지 않는 데이터베이스를 말하며, 대표적으로 MongoDB 와 redis 그리고 Elasticsearch 등이 있다.
### mongoDB
- 특징
  - JSON을 통해 데이터에 접근할수있고 Binary JSON 형태로 데이터가 저장된다.
  - 와이어드타이거 엔진이 기본 스토리지 엔진으로 장착된 키-값 데이터 모델에서 확장된 도큐먼트 기반의 데이터베이스이다.
  - 확장성이 뛰어나며 빅데이터를 저장할 때 성능이 좋고 고가용성과 샤딩, 레플리카셋을 지원한다.
  - 스키마를 정해 놓지 않고 데이터를 삽입할 수 있기 때문에 다양한 도메인의 데이터베이스를 기반으로 분석하거나 로깅 등을 구현할 때 강점을 보인다.
  - 도큐먼트 생성시 다른 컬렉션에서 중복된 값을 지니기 힘든 유니크한 값인 ObjectID가 생성된다.
 
### redis
- 특징
  - 인메모리 데이터베이스이다.
  - 키-값 데이터모델 기반이다.
  - 기본적인 데이터 타입은 문자열이며 최대 512MB까지 저장된다.
  - pub/sub 기능을 통해 채팅 시스템, 다른 데이터베이스 앞단에 두어 사용하는 캐싱 계층, 단순한 키-값이 필요한 세션 정보 관리, 정렬된 셋 자료 구조를 이용해서 실시간 순위표 서비스에 사용된다.

### 인덱스
 - 특징
   - 데이터를 빠르게 찾을 수 있는 하나의 장치이다.
   - 예시) 책에서 마지막 장에 있는 찾아보기 와 같은것을 보면좋다.
   - 인덱스를 설정하면 테이블 안에 찾고자 하는 데이터를 빠르게 찾을 수 있다.
### B-트리
- 특징
  - 인덱스는 보통 B-트리 자료구조로 이루어져있다.
  - 루트노드, 리프노드, 이 사이에 있는 브랜치노드가 있다.
    ![image](https://github.com/ukukdin/basic_CS_study/assets/97656198/77e23634-17b0-41d6-9798-9c264328e7cb)
 
예시)
 - 전체 테이블을 탐색하는 것이 아닌 찾고자 하는 값이 있을 법한 리프노드로 들어가서 탐색하면 쉽게 찾을 수 있다.
 - 이렇게 노드들로 나누면 두 번만에 리프노드에서 찾을 수 있다.(자료구조 없이는 모든값을 순차적으로 돌아야한다.)

### 인덱스가 효율적인 이유와 대수확장성
- 특징
  - 인덱스가 효율적인 이유는 효율적인 단계를 거쳐 모든 요소에 접근할 수 있는 균형 잡힌 트리 구조와 트리 깊이의 대수확장성 때문이다.
  - 대수확장성이란 트리 깊이가 리프노드 수에 비해 매우 느리게 성장하는 것을 의미한다.
  - 기본적으로 인덱스가 한 깊이씩 증가할 때마다 최대 인덱스 항목의 수는 4배씩 증가한다.

### 인덱스 만드는법 
  - MySQL
    - 클러스터형 인덱스와 세컨더리 인덱스가 있으며, 클러스터형 인덱스는 테이블당 하나를 설정할 수 있다.
    - primiary key 옵션으로 기본키로 만들면 클러스터형 인덱스가 생성된다.
    - 기본키로 만들지 않고 unique not null 옵션을 붙이면 클러스터형 인덱스로 만들 수 있다.
    - create index 명령어를 기반으로 만들면 세컨더리 인덱스를 만들수 있다.
    - 하나의 인덱스 생성시 클러스터형 인덱스보다 세컨더리 인덱스를 만드는것이 성능이 좋다.
  - MongoDB
    - 도큐먼트 생성시 자동으로 ObjectID가 형성된다.
    - 해당 키가 기본키로 설정된다.
    - 세컨더리키도 부가적으로 설정해서 기본키와 세컨더리키를 같이 쓰는 복합 인덱스를 설정가능하다.

### 인덱스 최적화 기법      
- 특징
  #### 인덱스는 비용이다
    -  인덱스는 두번 탐색을 강요한다( 인덱스 리스트 -> 컬렉션 순으로 탐색 하기 때문에, 관련 읽기 비용이 들게된다.)
    -  컬렉션이 수정 되었을 때 인덱스도 수정된다. (책의 본문 수정 시 목차도 수정되는것처럼)
    -  데이터를 효율적으로 조회할 수 있도록 분산 시키는 비용도 들게된다.
    -  B-트리 높이를 균형있게 조절하는 비용이 든다.
    -  데이터를 효율적으로 조회할 수 있도록 분산시키는 비용도 들게된다.
  - 단점
    - 컬렉션에서 가져와야 하는 양이 많을수록 인덱스를 사용하는 것은 비효율적이다.
  #### 항상 테스팅하라
    - 서비스에서 사용하는 객체의 깊이, 테이블의 양 등이 다르기 때문에 항상 테스팅 하는것이 중요하다.
    - explain() 함수를 통해 인덱스를 만들고 쿼리를 보낸 이후에 테스팅을 하며 걸리는 시간을 최소화해야된다.

      MySQL 에서 코드
      
      <code>
      EXPLAIN
      SELECT * FROM t1
      JOIN t2 ON t1.c1 =t2.c1
      </code>
   #### 복합 인덱스는 같음, 정렬, 다중 값, 커디널리티 순이다.
     - 여러 필드를 기반으로 조회할 때 복합 인덱스를 생성한다.
     - 생성에는 순서가 있고 순서에 따라 인덱스 성능이 달라진다.
       1. 어떠한 값과 같음을 비교하는 == 이나 equal 이라는 쿼리가 있다면 제일 먼저 인덱스로 설정해야한다.
       2. 정렬에 쓰는 필드라면 그다음 인덱스를 설정해야한다.
       3. 다중 값을 출력해야 하는 필드, 즉 쿼리 자체가 > 이거나 < 등 많은 값을 출력해야 하는 ㅝ리에 쓰는 필드라면 나중에 인덱스를 설정한다.
       4. 유니크한 값의 정도를 카디널리티라고 한다. 이 카디널리티가 높은 순서를 기반으로 인덱스를 생성해야 한다.
          - 예시) age 와 email 이 있다고 하면, 어떠한 것이 높을까? 당연히 email 이다. 즉, email 이라는 필드에 대한 인덱스를 먼저 생성해야 하는것이다.
            
### 조인의 종류
  - 특징
    - 조인(join) 이란 하나의 테이블이 아닌 두 개 이상의 테이블을 묶어서 하나의 결과물을 만드는 것을 말한다.
    - MySQl 에선 JOIN 쿼리
    - MongoDB에선 lookup 쿼리
    - MongoDB를 사용할 때 lookup의 사용은 되도록 피해야한다. MongoDB는 조인연산에 대한 관계형 데이터베이스보다 성능이 떨어진다고 여러 벤치마크 테스트에서 알려져 있다.
    - 조인이 많을 경우 MongoDB 보다 관계형 데이터베이스를 써야한다.


  - 조인의 종류
    
    ![image](https://github.com/ukukdin/basic_CS_study/assets/97656198/8020c175-ccb7-4d1e-87e9-d1d98f4906f5)

    - 내부 조인 : 왼쪽 테이블과 오른쪽 테이블의 두 행이 모두 일치하는 행이 있는 부분만 표기한다.
    - 왼쪽 조인 : 왼쪽 테이블의 모든 행이 결과 테이블에 표기된다.
    - 오른쪽 조인 : 오른쪽 테이블의 모든 행이 결과 테이블에 표기된다.
    - 합집합 조인 : 두 개의 테이블을 기반으로 조인 조건에 만족하지 않는 행까지 모두 표기한다. 

### 조인의 원리
- 특징
  ### 중첩 루프 조인
      - 중첩 루프 조인(NJL, Nested Loop Join)은 중첩 for 문과 같은 원리로 조건에 맞는 조인을 하는 방법이다.
      - 랜덤 접근에 대한 비용이 많이 증가하므로 대용량 테이블에서는 사용하지 않는다.
      - 예시) "t1,t2 테이블을 조인한다." 라고 했을 때 첫 번째 테이블에서 행을 한번에 하나씩 읽고 그 다음 테이블에서도 행을 하나씩 읽어 조건에 맞는 레코드를 찾아 결괏값을 반환한다.
        
        <code>
        for each row in t1 matching refrence key {
          for each row in t2 matching refrence key {
            if row satisfies join conditions, send to client
          }
        }
        </code>
        - 중첩 루프 조인에서 발전한 조인할 테이블을 작은 블록으로 나눠서 블록 하나씩 조인하는 블록 중첩 루프 조인이 라는 방식도 있다.
  ### 정렬 병합 조인
    - 특징
      - 정렬 병합조인이란 각각의 테이블을 조인할 필드 기준으로 정렬하고 정렬이 끝난 이후에 조인 작업을 수행하는 조인이다.
      - 조인할 때 쓸 적절한 인덱스가 없고 대용량의 테이블들을 조인하고 조인 조건으로 <,> 등 범위 비교 연산자가 있을 때 쓴다.
  ### 해시 조인
    - 특징
      - 해시 조인은 해시 테이블을 기반으로 조인하는 방법이다.
      - 두 개의 테이블을 조인할때 하나의 테이블이 메모리에 온전히 들어간다면 보통 중첩 루프 조인보다 더 효율적이다.
      - 동등(=) 조인에서만 사용할 수 있다.
      - MySQL 에서 해시조인 단계는 빌드 단계, 프로브 단계로 나뉜다.
     #### 빌드 단계
      - 입력 테이블 중 하나를 기반으로 메모리 내 해시 테이블을 빌드하는 단계이다.
      - 2개의 테이블을 조인할때 바이트가 더 작은 테이블을 기반으로 해시 테이블을 빌드한다.
     #### 프로브 단계  
      - 프로브 단계 동안 레코드 읽기를 시작하며 각 레코드에서 _id 에 일치하는 레코드를 찾아서 결과를 반환한다.
    이를 통해 각 테이블은 한번씩만 읽게 되어 중첩해서 두 개의 테이블을 읽는 중첩 로프 조인보다 보통은 성능이 더 좋다.
    참고 사항 : 사용 가능한 메모리양은 시스템 변수 join_buffer_size에 의해 제어되며, 런타임 시에 조정할 수 있다.
  
### 출처
[블로그]: https://velog.io/@mercurios0603/10%EB%B6%84-%ED%85%8C%EC%BD%94%ED%86%A1-%EC%9A%B0%EA%B8%B0%EC%9D%98-MySQL

